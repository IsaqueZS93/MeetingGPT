import streamlit as st
import logging
import datetime
from database.database_meeting import DatabaseMeeting
from audio_processing.audio_recorder import AudioRecorder
from audio_processing.transcribe import AudioTranscriber
from insights.insights_generator import InsightsGenerator

# Configura√ß√£o inicial do logger
logging.basicConfig(
    filename='screen_dmental.log',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

class DiaryScreen:
    def __init__(self, user_id=None):
        """
        Inicializa a tela de di√°rio mental, conectando-se ao banco de dados e configurando os m√≥dulos.
        """
        self.db = DatabaseMeeting()
        self.transcriber = AudioTranscriber()
        self.insights_generator = InsightsGenerator()
        self.user_id = user_id or st.session_state.get("user_id")

        # Inicializa vari√°veis no session_state
        self.init_session_state()

    def init_session_state(self):
        """Inicializa vari√°veis da sess√£o do Streamlit para evitar erros."""
        if "recording" not in st.session_state:
            st.session_state["recording"] = False
        if "audio_file_path" not in st.session_state:
            st.session_state["audio_file_path"] = None
        if "audio_recorder" not in st.session_state:
            st.session_state["audio_recorder"] = None
        if "user_id" not in st.session_state:
            st.session_state["user_id"] = self.user_id
        if "diary_data" not in st.session_state:
            st.session_state["diary_data"] = {
                "user_id": self.user_id,
                "type": "diary",
                "title": "",
                "participants": "Di√°rio Pessoal",
                "date": datetime.date.today().strftime("%Y-%m-%d"),
                "start_time": datetime.datetime.now().time().strftime("%H:%M"),
                "end_time": (datetime.datetime.now() + datetime.timedelta(hours=1)).time().strftime("%H:%M"),
                "transcript": "",
                "insights": ""
            }

    def render(self):
        """
        Renderiza a interface da tela de di√°rio mental usando Streamlit.
        """
        try:
            st.title("üìñ Di√°rio Mental")

            # Verifica se o usu√°rio est√° autenticado
            if not self.user_id:
                st.error("‚ö†Ô∏è Usu√°rio n√£o identificado. Fa√ßa login novamente.")
                return

            # Atualiza user_id na sess√£o
            st.session_state["diary_data"]["user_id"] = self.user_id

            # Campos de entrada
            st.session_state["diary_data"]["title"] = st.text_input("üìå T√≠tulo do Di√°rio:", st.session_state["diary_data"]["title"])
            st.session_state["diary_data"]["date"] = st.date_input("üìÖ Data do Di√°rio:", datetime.datetime.strptime(st.session_state["diary_data"]["date"], "%Y-%m-%d")).strftime("%Y-%m-%d")
            st.session_state["diary_data"]["start_time"] = st.time_input("‚è≥ Hor√°rio de In√≠cio:", datetime.datetime.strptime(st.session_state["diary_data"]["start_time"], "%H:%M")).strftime("%H:%M")
            st.session_state["diary_data"]["end_time"] = st.time_input("‚è≥ Hor√°rio de T√©rmino:", datetime.datetime.strptime(st.session_state["diary_data"]["end_time"], "%H:%M")).strftime("%H:%M")

            # üöÄ Bot√µes de controle do di√°rio
            if not st.session_state["recording"]:
                if st.button("üéôÔ∏è Iniciar Di√°rio"):
                    self.start_diary()

            if st.session_state["recording"]:
                if st.button("üõë Finalizar Di√°rio"):
                    self.stop_diary()

            if st.session_state["audio_file_path"]:
                if st.button("üìù Gerar Transcri√ß√£o e Insights"):
                    self.generate_transcription_and_insights()

            st.write("üí° **Nota:** Voc√™ pode editar as informa√ß√µes antes de salvar no banco de dados.")

        except Exception as e:
            logging.error(f"‚ùå Erro ao renderizar a tela de di√°rio mental: {e}")
            st.error("Ocorreu um erro ao carregar a tela de di√°rio mental.")

    def start_diary(self):
        """Inicia a grava√ß√£o de √°udio do di√°rio mental."""
        try:
            st.session_state["audio_recorder"] = AudioRecorder()
            st.session_state["audio_recorder"].start_recording()
            st.session_state["recording"] = True
            logging.info("üü¢ Di√°rio iniciado e grava√ß√£o de √°udio em andamento.")
            st.success("‚úÖ Di√°rio iniciado com sucesso. Grava√ß√£o de √°udio em andamento.")
        except Exception as e:
            logging.error(f"‚ùå Erro ao iniciar a grava√ß√£o: {e}")
            st.error("Erro ao iniciar a grava√ß√£o de √°udio.")

    def stop_diary(self):
        """Finaliza a grava√ß√£o do di√°rio mental e salva o √°udio."""
        try:
            if st.session_state["audio_recorder"]:
                st.session_state["audio_recorder"].stop_recording()
                st.session_state["recording"] = False
                audio_path = st.session_state["audio_recorder"].save_audio()

                if audio_path:
                    st.session_state["audio_file_path"] = audio_path
                    logging.info(f"üî¥ Grava√ß√£o finalizada e salva em: {audio_path}")
                    st.success(f"‚úÖ Grava√ß√£o finalizada. √Åudio salvo em: {audio_path}")
                else:
                    st.error("‚ùå Erro ao salvar o √°udio. O arquivo n√£o foi gerado.")
            else:
                st.error("‚ùå Nenhuma grava√ß√£o ativa foi encontrada.")
        except Exception as e:
            logging.error(f"‚ùå Erro ao parar a grava√ß√£o: {e}")
            st.error(f"Erro ao parar a grava√ß√£o: {e}")

    def generate_transcription_and_insights(self):
        """Gera a transcri√ß√£o e insights do √°udio gravado e salva no banco de dados."""
        try:
            if not self.user_id:
                st.error("‚ö†Ô∏è Usu√°rio n√£o identificado. Fa√ßa login novamente.")
                return

            audio_file_path = st.session_state["audio_file_path"]

            # Transcri√ß√£o do √°udio
            transcription_data = self.transcriber.transcribe_audio(audio_file_path)
            st.session_state["diary_data"]["transcript"] = transcription_data.get("text", "")

            # Gera√ß√£o de insights
            insights_data = self.insights_generator.generate_insights(st.session_state["diary_data"]["transcript"])
            st.session_state["diary_data"]["insights"] = insights_data.get("insights", "")

            # Atualiza o user_id no dicion√°rio antes de salvar no banco
            st.session_state["diary_data"]["user_id"] = self.user_id

            # Insere no banco de dados
            record_id = self.db.insert_record(st.session_state["diary_data"])
            st.success(f"‚úÖ Dados salvos com sucesso no banco de dados! ID: {record_id}")
            logging.info(f"üíæ Transcri√ß√£o e insights gerados e salvos no banco de dados. ID: {record_id}.")

        except Exception as e:
            logging.error(f"‚ùå Erro ao gerar transcri√ß√£o e insights: {e}")
            st.error("Erro ao gerar transcri√ß√£o e insights.")

    def cleanup(self):
        """Encerra a conex√£o com o banco de dados."""
        self.db.close_connection()

if __name__ == "__main__":
    screen = DiaryScreen()
    try:
        screen.render()
    finally:
        screen.cleanup()
