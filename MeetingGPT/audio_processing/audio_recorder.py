import os
import logging
import time
from datetime import datetime
import numpy as np
import av
import pydub
from streamlit_webrtc import WebRtcMode, webrtc_streamer
import streamlit as st

# Configura√ß√£o do logger
logging.basicConfig(
    filename='audio_recorder.log',
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# Diret√≥rio para salvar os √°udios
AUDIO_SAVE_PATH = r'C:\Users\Novaes Engenharia\MeetingGPT\data\audio'
os.makedirs(AUDIO_SAVE_PATH, exist_ok=True)

class AudioRecorder:
    def __init__(self):
        """ Inicializa o gravador de √°udio. """
        self.audio_frames = []
        self.is_recording = False
        st.session_state["audio_ready"] = False
        logging.debug("‚úÖ AudioRecorder inicializado.")

    def start_recording(self):
        """ Inicia a grava√ß√£o de √°udio usando streamlit-webrtc. """
        try:
            if self.is_recording:
                logging.warning("‚ö†Ô∏è Tentativa de iniciar uma grava√ß√£o j√° em andamento.")
                return

            self.is_recording = True
            self.audio_frames = []  # Resetar os frames de √°udio
            logging.info("üé¨ Iniciando o webrtc_streamer...")

            def callback(frame: av.AudioFrame):
                """ Callback para capturar frames de √°udio """
                self.audio_frames.append(frame)

            st.session_state["webrtc_ctx"] = webrtc_streamer(
                key="audio_capture",
                mode=WebRtcMode.SENDONLY,
                audio_receiver_size=1024,
                media_stream_constraints={"audio": True, "video": False},
                rtc_configuration={"iceServers": [{"urls": ["stun:stun.l.google.com:19302"]}]},
                async_processing=True,
                on_audio_frame=callback
            )
            
            logging.info("üü¢ Grava√ß√£o iniciada com sucesso.")
            st.write("üéôÔ∏è Gravando... Pressione o bot√£o para parar.")
        except Exception as e:
            logging.error(f"‚ùå Erro ao iniciar a grava√ß√£o: {e}")
            st.error(f"Erro ao iniciar a grava√ß√£o: {e}")

    def stop_recording(self):
        """ Finaliza a grava√ß√£o de √°udio e salva o arquivo. """
        try:
            if not self.is_recording:
                logging.warning("‚ö†Ô∏è Tentativa de parar uma grava√ß√£o que n√£o est√° em andamento.")
                st.warning("‚ö†Ô∏è Nenhuma grava√ß√£o ativa encontrada.")
                return

            self.is_recording = False

            if self.audio_frames:
                self.process_audio()
                st.session_state["audio_ready"] = True
                logging.info("üî¥ Grava√ß√£o finalizada com sucesso.")
                st.write("üî¥ Grava√ß√£o finalizada.")
            else:
                logging.warning("‚ö†Ô∏è Nenhum √°udio foi capturado.")
                st.warning("‚ö†Ô∏è Nenhum √°udio foi capturado.")
        except Exception as e:
            logging.error(f"‚ùå Erro ao parar a grava√ß√£o: {e}")
            st.error(f"Erro ao parar a grava√ß√£o: {e}")

    def process_audio(self):
        """ Processa os frames de √°udio capturados e converte para um arquivo de √°udio. """
        try:
            audio_segments = []
            for frame in self.audio_frames:
                audio = np.frombuffer(frame.to_ndarray().tobytes(), dtype=np.int16)
                segment = pydub.AudioSegment(
                    data=audio.tobytes(),
                    sample_width=frame.format.bytes,
                    frame_rate=frame.sample_rate,
                    channels=len(frame.layout.channels),
                )
                audio_segments.append(segment)
            
            self.audio_data = sum(audio_segments)
            logging.info("‚úÖ √Åudio processado com sucesso.")
        except Exception as e:
            logging.error(f"‚ùå Erro ao processar frames de √°udio: {e}")

    def save_audio(self, filename=None):
        """ Salva o √°udio gravado em um arquivo .wav. """
        try:
            if not st.session_state.get("audio_ready"):
                logging.error("‚ùå Nenhum √°udio capturado para salvar.")
                raise RuntimeError("Nenhum √°udio capturado para salvar.")

            if not filename:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"audio_{timestamp}.wav"

            filepath = os.path.join(AUDIO_SAVE_PATH, filename)
            self.audio_data.export(filepath, format="wav")

            logging.info(f"‚úÖ √Åudio salvo com sucesso: {filepath}")
            return filepath
        except Exception as e:
            logging.error(f"‚ùå Erro ao salvar o √°udio: {e}")
            st.error(f"Erro ao salvar o √°udio: {e}")
            raise RuntimeError(f"Erro ao salvar o √°udio: {e}")

# Exemplo de uso no Streamlit
if __name__ == "__main__":
    st.title("üéôÔ∏è Gravador de √Åudio - Streamlit WebRTC")
    recorder = AudioRecorder()

    if st.button("‚ñ∂Ô∏è Iniciar Grava√ß√£o"):
        try:
            recorder.start_recording()
        except Exception as e:
            st.error(f"Erro ao iniciar grava√ß√£o: {e}")

    if st.button("‚èπÔ∏è Parar Grava√ß√£o"):
        try:
            recorder.stop_recording()
            if st.session_state["audio_ready"]:
                filepath = recorder.save_audio()
                st.success(f"‚úÖ √Åudio salvo em: {filepath}")
            else:
                st.warning("‚ö†Ô∏è Nenhum √°udio foi capturado. Verifique as permiss√µes do microfone e tente novamente.")
        except Exception as e:
            st.error(f"Erro ao parar grava√ß√£o: {e}")
